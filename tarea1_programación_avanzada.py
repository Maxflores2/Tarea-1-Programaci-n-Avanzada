# -*- coding: utf-8 -*-
"""Tarea1_Programación_Avanzada

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1slYfmwHcvP_iMOjNing-sj7ox2OX3Yvd


## 3. Caminos en una PCB

Solución recursiva
"""

class CaminosPCB:
    def __init__(self, N, M): #constructor para la grilla de N*M
        self.N = N
        self.M = M

    def recursivo(self, i=0, j=0):
        if i == self.N - 1 and j == self.M - 1: #condición en la que llega al final
            return 1
        if i >= self.N or j >= self.M:
            return 0
        return self.recursivo(i + 1, j) + self.recursivo(i, j + 1) #llamado recursivo paa despazar hacia abajo y hacia la derecha

"""Solución iterativa"""

class CaminosPCB:
    def __init__(self, N, M):
        self.N = N
        self.M = M

    def iterativo(self):
        caminos = [1] * (self.M + 1) #arreglo de tamaño M+1 con puros 1

        for i in range(2, self.N + 1):
            for j in range(2, self.M + 1):
                caminos[j] += caminos[j - 1] #se agrega el valor de la fila sumandole la anterior de la izquierda

        return caminos[self.M]

"""Decorador"""

import time
import functools


def tiempo(func): #decorador
    @functools.wraps(func)
    def nueva_fun(*args, **kwargs):
        inicio = time.time()
        resultado = func(*args, **kwargs)
        fin = time.time()
        tiempo_total = fin - inicio
        print(f"Tiempo de ejecución de {func.__name__}: {tiempo_total:.6f} segundos")
        return resultado
    return nueva_fun

class CaminosPCB:
    def __init__(self, N, M):
        self.N = N
        self.M = M

    @tiempo
    def recursivo(self, i=0, j=0):
        if i == self.N - 1 and j == self.M - 1: #condición en la que llega al final
            return 1
        if i >= self.N or j >= self.M:
            return 0
        return self.recursivo(i + 1, j) + self.recursivo(i, j + 1) #llamado recursivo paa despazar hacia abajo y hacia la derecha

    @tiempo
    def iterativo(self):
        caminos = [1] * (self.M + 1) #arreglo de tamaño M+1 con puros 1

        for i in range(2, self.N + 1):
            for j in range(2, self.M + 1):
                caminos[j] += caminos[j - 1] #se agrega el valor de la fila sumandole la anterior de la izquierda

        return caminos[self.M]



pcb = CaminosPCB(6, 6)
print("Caminos (Iterativo):", pcb.iterativo())
print("Caminos (Recursivo):", pcb.recursivo())

"""## Para la parte final de hacer un gráfico que compare las soluciones en base al tiempo de ejecución, no logré implementarlo dado que tuve complicaciones con la manera de almacenar los tiempos de ejecución en la solución recursiva, pero la solución iterativa debería ser más eficiente debido a que la recursiva oma mucho tiempo al llamarse a si misma varias veces."""
