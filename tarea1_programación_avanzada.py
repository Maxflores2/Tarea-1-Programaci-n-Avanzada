# -*- coding: utf-8 -*-
"""Tarea1_Programación_Avanzada

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1slYfmwHcvP_iMOjNing-sj7ox2OX3Yvd

## Teóricas

¿Qué es un paradigma de programación?

 Es una forma de enfocar y formular problemas de programación. Un ejemplo de los paradigmas de programación son los imperativos, los cuales son básicamente una secuencia de pasos que van cambiando el estado del programa. Dentro de este tipo de paradígmas estan la procedimental, orientada a objetos y procesamiento paralelo.

 ¿En qué se basa la programación orientada a objetos?

 Este tipo de programación se basa en la creación de una clase, la cual tiene objetos definidos. Los objetos de cada clase tiene atributos y funcionalidades asociados. Una característica es la capacidad del enfasis en los datos y la herencia que se pueden tener entre objetos.

¿Cuál es la diferencia entre recursividad e iteración, y cómo se relaciona esto con la notación big 𝑂?

La iteración se basa en realizar el mismo procedimiento varias veces ocupando ciclos for o bucles while. En cambio, la recursividad consiste en llamar a si mismo la función, ya sea directamente o indirectamente. En términos de la complejidad con la notación big O, la iteratividad en la mayoria de los casos tiene complejidad O(n), en cambio la recursividad puede tener distintas complejidades según la forma en que esté planteada y si ocupa espacios en la memoria o no.

Explicar la diferencia de rendimiento entre 𝑂(1) y 𝑂(𝑛)

La complejidad O(1), corresponde a un tiempo constante de ejecución del algoritmo sin importar la entrada que tenga. El caso de O(n) es un tiempo de ejecución lineal, es decir, el tiempo de ejecución es proporcional al tamaño de la entrada al algoritmo. Por lo tanto, O(1) es mucho más eficiente que O(n) para cualquier tamaño de entrada.

¿Cómo se calcula el orden en un programa que funciona por etapas?

Depende de como este compuesto el programa por etapas, esto podría ser en serie o anidado de alguna manera. En el caso de que este compuesto por etapas en serie, la complejidad big O del algoritmo corresponde a la suma de las complejidades de cada etapa. En el caso de las etapas anidadas, para obtener la complejidad big O del algoritmo completo se debe hacer la multiplicación de complejidades de cada etapa.

¿Cómo se puede determinar la complejidad temporal de un algoritmo recursivo?

Se puede establecer una relación de recurrencia, la cual depende de la cantidad de veces que se llama a si mismo la función y de la cantidad de subproblemas que se tienen en total.

## 3. Caminos en una PCB

Solución recursiva
"""

class CaminosPCB:
    def __init__(self, N, M): #constructor para la grilla de N*M
        self.N = N
        self.M = M

    def recursivo(self, i=0, j=0):
        if i == self.N - 1 and j == self.M - 1: #condición en la que llega al final
            return 1
        if i >= self.N or j >= self.M:
            return 0
        return self.recursivo_simple(i + 1, j) + self.recursivo_simple(i, j + 1) #llamado recursivo paa despazar hacia abajo y hacia la derecha

"""Solución iterativa"""

class CaminosPCB:
    def __init__(self, N, M):
        self.N = N
        self.M = M

    def iterativo(self):
        caminos = [1] * (self.M + 1) #arreglo de tamaño M+1 con puros 1

        for i in range(2, self.N + 1):
            for j in range(2, self.M + 1):
                caminos[j] += caminos[j - 1] #se agrega el valor de la fila sumandole la anterior de la izquierda

        return caminos[self.M]

"""Decorador"""

import time
import functools


def tiempo(func): #decorador
    @functools.wraps(func)
    def nueva_fun(*args, **kwargs):
        inicio = time.time()
        resultado = func(*args, **kwargs)
        fin = time.time()
        tiempo_total = fin - inicio
        print(f"Tiempo de ejecución de {func.__name__}: {tiempo_total:.6f} segundos")
        return resultado
    return nueva_fun

class CaminosPCB:
    def __init__(self, N, M):
        self.N = N
        self.M = M

    @tiempo
    def recursivo(self, i=0, j=0):
        if i == self.N - 1 and j == self.M - 1: #condición en la que llega al final
            return 1
        if i >= self.N or j >= self.M:
            return 0
        return self.recursivo(i + 1, j) + self.recursivo(i, j + 1) #llamado recursivo paa despazar hacia abajo y hacia la derecha

    @tiempo
    def iterativo(self):
        caminos = [1] * (self.M + 1) #arreglo de tamaño M+1 con puros 1

        for i in range(2, self.N + 1):
            for j in range(2, self.M + 1):
                caminos[j] += caminos[j - 1] #se agrega el valor de la fila sumandole la anterior de la izquierda

        return caminos[self.M]



pcb = CaminosPCB(6, 6)
print("Caminos (Iterativo):", pcb.iterativo())
print("Caminos (Recursivo):", pcb.recursivo())

"""## Para la parte final de hacer un gráfico que compare las soluciones en base al tiempo de ejecución, no logré implementarlo dado que tuve complicaciones con la manera de almacenar los tiempos de ejecución en la solución recursiva."""