# -*- coding: utf-8 -*-
"""Tarea1_Programaci贸n_Avanzada

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1slYfmwHcvP_iMOjNing-sj7ox2OX3Yvd

## Te贸ricas

驴Qu茅 es un paradigma de programaci贸n?

 Es una forma de enfocar y formular problemas de programaci贸n. Un ejemplo de los paradigmas de programaci贸n son los imperativos, los cuales son b谩sicamente una secuencia de pasos que van cambiando el estado del programa. Dentro de este tipo de parad铆gmas estan la procedimental, orientada a objetos y procesamiento paralelo.

 驴En qu茅 se basa la programaci贸n orientada a objetos?

 Este tipo de programaci贸n se basa en la creaci贸n de una clase, la cual tiene objetos definidos. Los objetos de cada clase tiene atributos y funcionalidades asociados. Una caracter铆stica es la capacidad del enfasis en los datos y la herencia que se pueden tener entre objetos.

驴Cu谩l es la diferencia entre recursividad e iteraci贸n, y c贸mo se relaciona esto con la notaci贸n big ?

La iteraci贸n se basa en realizar el mismo procedimiento varias veces ocupando ciclos for o bucles while. En cambio, la recursividad consiste en llamar a si mismo la funci贸n, ya sea directamente o indirectamente. En t茅rminos de la complejidad con la notaci贸n big O, la iteratividad en la mayoria de los casos tiene complejidad O(n), en cambio la recursividad puede tener distintas complejidades seg煤n la forma en que est茅 planteada y si ocupa espacios en la memoria o no.

Explicar la diferencia de rendimiento entre (1) y ()

La complejidad O(1), corresponde a un tiempo constante de ejecuci贸n del algoritmo sin importar la entrada que tenga. El caso de O(n) es un tiempo de ejecuci贸n lineal, es decir, el tiempo de ejecuci贸n es proporcional al tama帽o de la entrada al algoritmo. Por lo tanto, O(1) es mucho m谩s eficiente que O(n) para cualquier tama帽o de entrada.

驴C贸mo se calcula el orden en un programa que funciona por etapas?

Depende de como este compuesto el programa por etapas, esto podr铆a ser en serie o anidado de alguna manera. En el caso de que este compuesto por etapas en serie, la complejidad big O del algoritmo corresponde a la suma de las complejidades de cada etapa. En el caso de las etapas anidadas, para obtener la complejidad big O del algoritmo completo se debe hacer la multiplicaci贸n de complejidades de cada etapa.

驴C贸mo se puede determinar la complejidad temporal de un algoritmo recursivo?

Se puede establecer una relaci贸n de recurrencia, la cual depende de la cantidad de veces que se llama a si mismo la funci贸n y de la cantidad de subproblemas que se tienen en total.

## 3. Caminos en una PCB

Soluci贸n recursiva
"""

class CaminosPCB:
    def __init__(self, N, M): #constructor para la grilla de N*M
        self.N = N
        self.M = M

    def recursivo(self, i=0, j=0):
        if i == self.N - 1 and j == self.M - 1: #condici贸n en la que llega al final
            return 1
        if i >= self.N or j >= self.M:
            return 0
        return self.recursivo_simple(i + 1, j) + self.recursivo_simple(i, j + 1) #llamado recursivo paa despazar hacia abajo y hacia la derecha

"""Soluci贸n iterativa"""

class CaminosPCB:
    def __init__(self, N, M):
        self.N = N
        self.M = M

    def iterativo(self):
        caminos = [1] * (self.M + 1) #arreglo de tama帽o M+1 con puros 1

        for i in range(2, self.N + 1):
            for j in range(2, self.M + 1):
                caminos[j] += caminos[j - 1] #se agrega el valor de la fila sumandole la anterior de la izquierda

        return caminos[self.M]

"""Decorador"""

import time
import functools


def tiempo(func): #decorador
    @functools.wraps(func)
    def nueva_fun(*args, **kwargs):
        inicio = time.time()
        resultado = func(*args, **kwargs)
        fin = time.time()
        tiempo_total = fin - inicio
        print(f"Tiempo de ejecuci贸n de {func.__name__}: {tiempo_total:.6f} segundos")
        return resultado
    return nueva_fun

class CaminosPCB:
    def __init__(self, N, M):
        self.N = N
        self.M = M

    @tiempo
    def recursivo(self, i=0, j=0):
        if i == self.N - 1 and j == self.M - 1: #condici贸n en la que llega al final
            return 1
        if i >= self.N or j >= self.M:
            return 0
        return self.recursivo(i + 1, j) + self.recursivo(i, j + 1) #llamado recursivo paa despazar hacia abajo y hacia la derecha

    @tiempo
    def iterativo(self):
        caminos = [1] * (self.M + 1) #arreglo de tama帽o M+1 con puros 1

        for i in range(2, self.N + 1):
            for j in range(2, self.M + 1):
                caminos[j] += caminos[j - 1] #se agrega el valor de la fila sumandole la anterior de la izquierda

        return caminos[self.M]



pcb = CaminosPCB(6, 6)
print("Caminos (Iterativo):", pcb.iterativo())
print("Caminos (Recursivo):", pcb.recursivo())

"""## Para la parte final de hacer un gr谩fico que compare las soluciones en base al tiempo de ejecuci贸n, no logr茅 implementarlo dado que tuve complicaciones con la manera de almacenar los tiempos de ejecuci贸n en la soluci贸n recursiva."""